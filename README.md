# Эмулятор двухадресного RISC процессора

## Описание проекта

Данный проект представляет собой полнофункциональный эмулятор двухадресного RISC процессора с архитектурой Фон-Неймана. Эмулятор реализует систему команд с фиксированной длиной, поддерживает различные режимы адресации и включает в себя ассемблер для компиляции исходного кода в машинные инструкции.

## Архитектура процессора

### Основные характеристики
- **Тип архитектуры:** Двухадресная RISC с архитектурой Фон-Неймана
- **Разрядность:** 16-битные регистры, 16/32-битные команды
- **Память:** 4096 ячеек по 16 бит (адреса 0x0000-0x0FFF)
- **Регистры:** 8 регистров общего назначения (R0-R7)

### Регистры процессора
- **R0-R7** - регистры общего назначения (16 бит каждый)
- **R0** - аккумулятор (основной регистр для вычислений)
- **PC** - счетчик команд (16 бит)
- **IR** - регистр команд (16/32 бита)

### Флаги состояния
- **Z (Zero)** - флаг нуля
- **C (Carry)** - флаг переноса
- **V (Overflow)** - флаг переполнения
- **N (Negative)** - флаг знака

## Система команд

### Формат команд
- **16-битные команды (R-тип):** регистр-регистр операции
- **32-битные команды (I-тип):** с непосредственными значениями

### Структура команды
```
[15:12] - код операции (4 бита)
[11:9]  - регистр назначения rd (3 бита)
[8:6]   - первый исходный регистр rs1 (3 бита)
[5:3]   - второй исходный регистр rs2 (3 бита)
[2:0]   - режим адресации (3 бита)
[31:16] - непосредственное значение (для I-типа)
```

### Режимы адресации
- **Непосредственная (0):** LDI R0, 100
- **Прямая (1):** LDR R0, [0x1000]
- **Регистровая (2):** ADD R0, R1, R2
- **Косвенно-регистровая (3):** LDRR R0, [R1]

### Команды процессора

#### Арифметико-логические операции (R-тип)
- `ADD rd, rs1, rs2` - сложение: rd = rs1 + rs2
- `SUB rd, rs1, rs2` - вычитание: rd = rs1 - rs2
- `MUL rd, rs1, rs2` - умножение: rd = rs1 * rs2
- `DIV rd, rs1, rs2` - деление: rd = rs1 / rs2
- `AND rd, rs1, rs2` - логическое И: rd = rs1 & rs2
- `OR rd, rs1, rs2` - логическое ИЛИ: rd = rs1 | rs2
- `XOR rd, rs1, rs2` - исключающее ИЛИ: rd = rs1 ^ rs2
- `NOT rd, rs1` - логическое НЕ: rd = ~rs1

#### Команды пересылки данных
- `MOV rd, rs1` - копирование регистра: rd = rs1
- `LDI rd, imm` - загрузка константы: rd = immediate
- `LDR rd, [address]` - загрузка из памяти (прямая): rd = [address]
- `LDRR rd, [rs1]` - загрузка из памяти (косвенная): rd = [rs1]
- `STR rs1, [address]` - сохранение в память (прямая): [address] = rs1
- `STRR rs1, [rd]` - сохранение в память (косвенная): [rd] = rs1

#### Команды сравнения и переходов
- `CMP rs1, rs2` - сравнение (устанавливает флаги): rs1 - rs2
- `JMP address` - безусловный переход
- `JZ address` - переход если Z=1
- `JNZ address` - переход если Z=0
- `JC address` - переход если C=1
- `JNC address` - переход если C=0
- `JV address` - переход если V=1
- `JNV address` - переход если V=0
- `JN address` - переход если N=1
- `JNN address` - переход если N=0

#### Системные команды
- `HALT` - остановка выполнения
- `NOP` - нет операции

## Предустановленные задачи

### Задача 1: Сумма элементов массива
**Описание:** Вычислить сумму всех элементов массива из 6-15 элементов
**Входные данные:** Массив [7, 10, 20, 30, 40, 50, 60, 70] (размер: 7)
**Ожидаемый результат:** 280 (в регистре R0)
**Особенности:** Использование цикла с командами CMP, JZ, JMP

### Задача 2: Свертка двух массивов
**Описание:** Вычислить свертку двух массивов по 10 элементов каждый
**Входные данные:** 
- Массив A: [2, 3, 1, 4, 5, 2, 3, 1, 4, 2]
- Массив B: [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]
**Ожидаемый результат:** 50 (в памяти по адресу 0x1100)
**Формула:** Σ(A[i] * B[i]) для i=0..9

## Техническая структура

### Backend (Python/FastAPI)
```
backend/
├── app/
│   ├── __init__.py
│   ├── main.py              # FastAPI приложение
│   ├── models.py            # Pydantic модели данных
│   ├── processor.py         # RISC процессор
│   ├── assembler.py         # Ассемблер
│   ├── emulator.py          # Основной эмулятор
│   └── tasks.py             # Предустановленные задачи
├── requirements.txt
└── Dockerfile
```

### Frontend (React/TypeScript)
```
frontend/
├── src/
│   ├── components/
│   │   ├── CommandEditor/   # Редактор команд
│   │   ├── ControlPanel/    # Панель управления
│   │   ├── MemoryView/      # Просмотр памяти
│   │   ├── ProcessorView/   # Отображение процессора
│   │   ├── TaskPanel/       # Панель задач
│   │   └── ErrorDisplay/    # Отображение ошибок
│   ├── services/
│   │   └── api.ts           # API клиент
│   ├── store/
│   │   └── emulatorStore.ts # Zustand store
│   └── types/
│       └── emulator.ts      # TypeScript типы
├── package.json
└── Dockerfile
```

## Установка и запуск

### Предварительные требования
- Python 3.8+
- Node.js 16+
- npm или yarn

### Установка зависимостей

#### Backend
```bash
cd backend
pip install -r requirements.txt
```

#### Frontend
```bash
cd frontend
npm install
```

### Запуск в режиме разработки

#### Backend
```bash
cd backend
python -m app.main
```
Сервер будет доступен по адресу: http://localhost:8000

#### Frontend
```bash
cd frontend
npm run dev
```
Приложение будет доступно по адресу: http://localhost:5173

### Запуск через Docker
```bash
# Из корневой папки проекта
docker-compose up
```

## API документация

### Основные endpoints
- `GET /` - информация о сервере
- `GET /api/state` - текущее состояние эмулятора
- `POST /api/compile` - компиляция исходного кода
- `POST /api/load-task` - загрузка задачи
- `POST /api/execute` - выполнение программы
- `POST /api/step` - выполнение одного шага
- `POST /api/reset` - сброс процессора
- `GET /api/tasks` - список задач
- `GET /api/instruction/{instruction}` - информация об инструкции

### Документация API
- Swagger UI: http://localhost:8000/docs
- ReDoc: http://localhost:8000/redoc

## Использование эмулятора

### Интерфейс процессора
- **Регистры R0-R7:** отображение текущих значений всех регистров
- **Счетчик команд (PC):** текущая позиция в программе
- **Регистр команд (IR):** текущая команда в машинном коде и ассемблере
- **Флаги состояния:** Z, C, V, N с визуальными индикаторами
- **Циклы выполнения:** счетчик выполненных команд

### Редактор команд
- Поддержка синтаксиса ассемблера
- Подсветка синтаксиса
- Компиляция в реальном времени
- Отображение ошибок компиляции

### Просмотр памяти
- Отображение содержимого ОЗУ
- История выполнения команд
- Отслеживание изменений регистров
- Форматирование данных (десятичное/шестнадцатеричное)

### Панель управления
- Кнопки выполнения (шаг/полностью)
- Сброс процессора
- Выбор предустановленных задач
- Загрузка пользовательского кода

## Примеры программ

### Пример 1: Простое сложение
```assembly
; Загрузка констант в регистры
LDI R1, 10      ; R1 = 10
LDI R2, 20      ; R2 = 20

; Сложение
ADD R0, R1, R2  ; R0 = R1 + R2 = 30

; Остановка
HALT
```

### Пример 2: Цикл с условием
```assembly
; Инициализация
LDI R1, 0       ; R1 = 0 (счетчик)
LDI R2, 5       ; R2 = 5 (предел)

LOOP_START:
; Проверка условия
CMP R1, R2      ; Сравнить R1 и R2
JZ LOOP_END     ; Если R1 == R2, выйти

; Тело цикла
ADD R0, R0, R1  ; R0 = R0 + R1
ADD R1, R1, 1   ; R1 = R1 + 1

; Переход к началу цикла
JMP LOOP_START

LOOP_END:
HALT
```

### Пример 3: Работа с памятью
```assembly
; Загрузка данных в память
LDI R1, 100
STR R1, [0x1000]  ; [0x1000] = 100

; Загрузка из памяти
LDR R2, [0x1000]  ; R2 = [0x1000] = 100

; Косвенная адресация
LDI R3, 0x1000
LDRR R4, [R3]     ; R4 = [R3] = 100

HALT
```

## Особенности реализации

### Ассемблер
- Двухпроходная компиляция
- Поддержка меток для переходов
- Проверка синтаксиса команд
- Генерация машинного кода

### Процессор
- Пошаговое выполнение команд
- Обновление флагов после операций
- Проверка переполнения для 16-битных чисел
- Обработка ошибок выполнения

### Интерфейс
- Реактивное обновление состояния
- Анимации изменений регистров и флагов
- Поддержка разных форматов отображения
- Адаптивный дизайн

## Отладка и диагностика

### Логирование
- Детальные логи выполнения команд
- Отслеживание изменений регистров
- История операций с памятью
- Информация об ошибках

### Валидация
- Проверка корректности команд
- Валидация адресов памяти
- Контроль переполнения
- Проверка результатов задач

## Требования к системе

### Минимальные требования
- Python 3.8+
- Node.js 16+
- 4 GB RAM
- 1 GB свободного места

### Рекомендуемые требования
- Python 3.11+
- Node.js 18+
- 8 GB RAM
- 2 GB свободного места

## Лицензия

Проект разработан в учебных целях для демонстрации принципов работы процессора и системы команд.

## Поддержка

При возникновении проблем проверьте:
1. Установлены ли все зависимости
2. Запущены ли оба сервера (backend и frontend)
3. Нет ли конфликтов портов
4. Корректно ли настроены переменные окружения

Для получения помощи обратитесь к документации API или изучите примеры программ в разделе "Примеры программ".