# Эмулятор двухадресного RISC процессора

## Описание проекта

Данный проект представляет собой полнофункциональный веб-эмулятор двухадресного RISC процессора с архитектурой Фон-Неймана. Эмулятор реализует систему команд с фиксированной длиной, поддерживает различные режимы адресации и включает в себя ассемблер для компиляции исходного кода в машинные инструкции.

### Основные возможности

- **Полная эмуляция RISC процессора** - реализация двухадресной архитектуры с 8 регистрами общего назначения
- **Ассемблер** - двухпроходная компиляция с поддержкой меток и различных форматов чисел
- **Веб-интерфейс** - современный React-интерфейс с визуализацией состояния процессора
- **Пошаговое выполнение** - возможность выполнять программу пошагово для отладки
- **Предустановленные задачи** - готовые задачи для тестирования и обучения
- **REST API** - полный набор endpoints для управления эмулятором
- **Docker поддержка** - легкий запуск через Docker Compose

---

## Архитектура процессора

### Основные характеристики

- **Тип архитектуры:** Двухадресная RISC с архитектурой Фон-Неймана
- **Разрядность:** 16-битные регистры, 16/32-битные команды
- **Память:** 8192 ячеек по 16 бит (адреса 0x0000-0x1FFF)
- **Регистры:** 8 регистров общего назначения (R0-R7)
- **Формат команд:** R-тип (16 бит) и I-тип (32 бита)

### Регистры процессора

| Регистр | Назначение | Разрядность |
|---------|-----------|-------------|
| **R0-R7** | Регистры общего назначения | 16 бит |
| **R0** | Аккумулятор (основной регистр для вычислений) | 16 бит |
| **PC** | Счетчик команд (Program Counter) | 16 бит |
| **IR** | Регистр команд (Instruction Register) | 16/32 бита |

### Флаги состояния

Процессор поддерживает 4 флага состояния, которые устанавливаются после выполнения арифметических и логических операций:

- **Z (Zero)** - флаг нуля: устанавливается в 1, если результат операции равен нулю
- **C (Carry)** - флаг переноса: устанавливается при переполнении при сложении/вычитании
- **V (Overflow)** - флаг переполнения: устанавливается при выходе результата за пределы 16-битного диапазона (-32768..32767)
- **N (Negative)** - флаг знака: устанавливается в 1, если результат отрицательный

---

## Система команд

### Формат команд

Процессор поддерживает два формата команд:

- **16-битные команды (R-тип):** операции регистр-регистр
- **32-битные команды (I-тип):** команды с непосредственными значениями

### Структура команды

```
16-битный формат (R-тип):
┌─────┬─────┬─────┬─────┬─────┐
│ 15  │ 12  │ 11  │ 9   │ 8   │ 6  │ 5  │ 3  │ 2  │ 0  │
├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
│ OPCODE (4 бита) │ RD │ RS1 │ RS2 │ MODE (3 бита) │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘

32-битный формат (I-тип):
┌─────────────────┬─────────────────────────────────────┐
│ 31               │ 16  │ 15  │ 12  │ 11  │ 9  │ ... │
├─────────────────┼─────┼─────┼─────┼─────┼─────┤
│ IMMEDIATE (16)   │ OPCODE │ RD │ RS1 │ RS2 │ MODE │
└─────────────────┴─────┴─────┴─────┴─────┴─────┘
```

**Поля команды:**
- `[15:12]` или `[31:28]` - код операции (4 бита)
- `[11:9]` - регистр назначения rd (3 бита)
- `[8:6]` - первый исходный регистр rs1 (3 бита)
- `[5:3]` - второй исходный регистр rs2 (3 бита)
- `[2:0]` - режим адресации (3 бита)
- `[31:16]` - непосредственное значение (для I-типа, 16 бит)

### Режимы адресации

Процессор поддерживает 4 режима адресации:

| Код | Режим | Описание | Пример |
|-----|-------|----------|--------|
| 0 | Непосредственная | Значение указано в команде | `LDI R0, 100` |
| 1 | Прямая | Адрес указан в команде | `LDR R0, [0x1000]` |
| 2 | Регистровая | Значение в регистре | `ADD R0, R1, R2` |
| 3 | Косвенно-регистровая | Адрес в регистре | `LDRR R0, [R1]` |

---

## Справочник команд

### Арифметико-логические операции (R-тип)

| Команда | Код | Формат | Описание |
|---------|-----|--------|----------|
| `ADD` | 0x01 | `ADD rd, rs1, rs2` | Сложение: rd = rs1 + rs2 |
| `SUB` | 0x02 | `SUB rd, rs1, rs2` | Вычитание: rd = rs1 - rs2 |
| `MUL` | 0x03 | `MUL rd, rs1, rs2` | Умножение: rd = rs1 * rs2 |
| `DIV` | 0x04 | `DIV rd, rs1, rs2` | Деление: rd = rs1 / rs2 |
| `AND` | 0x05 | `AND rd, rs1, rs2` | Логическое И: rd = rs1 & rs2 |
| `OR` | 0x06 | `OR rd, rs1, rs2` | Логическое ИЛИ: rd = rs1 \| rs2 |
| `XOR` | 0x07 | `XOR rd, rs1, rs2` | Исключающее ИЛИ: rd = rs1 ^ rs2 |
| `NOT` | 0x08 | `NOT rd, rs1` | Логическое НЕ: rd = ~rs1 |

**Особенности:**
- Все операции устанавливают флаги Z, N, V, C
- При делении на ноль генерируется ошибка
- Переполнение отслеживается для 16-битных значений

### Команды пересылки данных

| Команда | Код | Формат | Описание |
|---------|-----|--------|----------|
| `MOV` | 0x10 | `MOV rd, rs1` | Копирование регистра: rd = rs1 |
| `LDI` | 0x11 | `LDI rd, imm` | Загрузка константы: rd = immediate |
| `LDR` | 0x12 | `LDR rd, [address]` | Загрузка из памяти (прямая): rd = [address] |
| `LDRR` | 0x13 | `LDRR rd, [rs1]` | Загрузка из памяти (косвенная): rd = [rs1] |
| `STR` | 0x14 | `STR rs1, [address]` | Сохранение в память (прямая): [address] = rs1 |
| `STRR` | 0x15 | `STRR rs1, [rd]` | Сохранение в память (косвенная): [rd] = rs1 |

**Форматы чисел:**
- Десятичное: `100`, `-50`
- Шестнадцатеричное: `0x1000`, `0xFF`
- Двоичное: `0b1010`

### Команды сравнения и переходов

| Команда | Код | Формат | Описание |
|---------|-----|--------|----------|
| `CMP` | 0x20 | `CMP rs1, rs2` | Сравнение (устанавливает флаги): rs1 - rs2 |
| `JMP` | 0x21 | `JMP address` | Безусловный переход |
| `JZ` | 0x22 | `JZ address` | Переход если Z=1 (результат равен нулю) |
| `JNZ` | 0x23 | `JNZ address` | Переход если Z=0 (результат не равен нулю) |
| `JC` | 0x24 | `JC address` | Переход если C=1 (есть перенос) |
| `JNC` | 0x25 | `JNC address` | Переход если C=0 (нет переноса) |
| `JV` | 0x26 | `JV address` | Переход если V=1 (есть переполнение) |
| `JNV` | 0x27 | `JNV address` | Переход если V=0 (нет переполнения) |
| `JN` | 0x28 | `JN address` | Переход если N=1 (результат отрицательный) |
| `JNN` | 0x29 | `JNN address` | Переход если N=0 (результат неотрицательный) |

**Особенности переходов:**
- Адрес может быть меткой или числом
- При переходе PC устанавливается на указанный адрес
- После перехода выполнение продолжается с нового адреса

### Системные команды

| Команда | Код | Формат | Описание |
|---------|-----|--------|----------|
| `HALT` | 0xFF | `HALT` | Остановка выполнения программы |
| `NOP` | 0x00 | `NOP` | Нет операции (задержка) |

---

## Предустановленные задачи

### Задача 1: Сумма элементов массива

**Описание:** Вычислить сумму всех элементов массива из 6-15 элементов.

**Входные данные:**
- Массив: `[7, 10, 20, 30, 40, 50, 60, 70]`
- Формат: первый элемент - размер массива (7), далее - элементы массива
- Массив хранится в памяти начиная с адреса `0x1000`

**Ожидаемый результат:** `280` (в регистре R0)

**Особенности:**
- Использование цикла с командами `CMP`, `JZ`, `JMP`
- Косвенно-регистровая адресация для доступа к элементам массива
- Инкремент индекса и проверка условия выхода из цикла

**Алгоритм:**
1. Инициализация: R0 = 0 (аккумулятор), R1 = 1 (индекс)
2. Загрузка размера массива из памяти
3. Цикл: пока индекс <= размер
   - Вычисление адреса элемента
   - Загрузка элемента в регистр
   - Добавление к сумме
   - Увеличение индекса
4. Результат в R0

### Задача 2: Свертка двух массивов

**Описание:** Вычислить свертку (скалярное произведение) двух массивов по 10 элементов каждый.

**Входные данные:**
- Массив A: `[2, 3, 1, 4, 5, 2, 3, 1, 4, 2]` (адреса 0x1000-0x1009)
- Массив B: `[1, 2, 3, 1, 2, 3, 1, 2, 3, 1]` (адреса 0x1010-0x1019)

**Ожидаемый результат:** `50` (в памяти по адресу 0x1100)

**Формула:** Σ(A[i] * B[i]) для i=0..9

**Особенности:**
- Работа с двумя массивами одновременно
- Использование команды `MUL` для умножения элементов
- Сохранение результата в память

**Алгоритм:**
1. Инициализация: R0 = 0 (аккумулятор), R1 = 0 (индекс)
2. Цикл: для i от 0 до 9
   - Загрузка A[i] из памяти
   - Загрузка B[i] из памяти
   - Умножение A[i] * B[i]
   - Добавление произведения к сумме
   - Увеличение индекса
3. Сохранение результата в память по адресу 0x1100

---

## Техническая структура

### Backend (Python/FastAPI)

```
backend/
├── app/
│   ├── __init__.py
│   ├── main.py              # FastAPI приложение и API endpoints
│   ├── models.py            # Pydantic модели данных
│   ├── processor.py         # RISC процессор (эмуляция выполнения)
│   ├── assembler.py         # Ассемблер (компиляция кода)
│   ├── emulator.py          # Основной эмулятор (координация)
│   └── tasks.py             # Предустановленные задачи
├── requirements.txt         # Python зависимости
└── Dockerfile              # Docker образ для backend
```

**Технологии:**
- Python 3.8+
- FastAPI 0.104.1
- Pydantic 2.5.0
- Uvicorn 0.24.0

**Основные компоненты:**

1. **RISCProcessor** (`processor.py`) - эмуляция процессора:
   - Выполнение команд
   - Управление регистрами и памятью
   - Обновление флагов состояния
   - Пошаговое выполнение

2. **RISCAssembler** (`assembler.py`) - компилятор:
   - Двухпроходная компиляция
   - Парсинг команд и операндов
   - Обработка меток
   - Генерация машинного кода

3. **RISCEmulator** (`emulator.py`) - координатор:
   - Управление состоянием эмулятора
   - Загрузка и выполнение программ
   - Работа с задачами
   - Верификация результатов

### Frontend (React/TypeScript)

```
frontend/
├── src/
│   ├── components/
│   │   ├── CommandEditor/   # Редактор команд с подсветкой
│   │   ├── ControlPanel/    # Панель управления (шаг/выполнить/сброс)
│   │   ├── MemoryView/      # Просмотр памяти и истории
│   │   ├── ProcessorView/   # Отображение процессора (регистры, флаги, PC)
│   │   ├── TaskPanel/       # Панель задач
│   │   ├── ErrorDisplay/    # Отображение ошибок
│   │   └── TechStack/       # Информация о технологиях
│   ├── services/
│   │   └── api.ts           # API клиент (HTTP запросы)
│   ├── store/
│   │   └── emulatorStore.ts # Zustand store (управление состоянием)
│   ├── types/
│   │   └── emulator.ts      # TypeScript типы
│   ├── App.tsx              # Главный компонент
│   └── main.tsx             # Точка входа
├── package.json
├── vite.config.ts
└── Dockerfile
```

**Технологии:**
- React 19.1.1
- TypeScript 5.8.3
- Vite 5.0.0
- Zustand 5.0.8 (управление состоянием)
- PrimeReact 10.9.7 (UI компоненты)
- Flowbite React 0.12.9 (UI компоненты)

---

## Установка и запуск

### Предварительные требования

- **Python:** 3.8 или выше
- **Node.js:** 16 или выше
- **npm** или **yarn**
- **Docker** и **Docker Compose** (опционально, для контейнеризации)

### Установка зависимостей

#### Backend

```bash
cd backend
pip install -r requirements.txt
```

**Зависимости:**
- `fastapi==0.104.1` - веб-фреймворк
- `uvicorn[standard]==0.24.0` - ASGI сервер
- `pydantic==2.5.0` - валидация данных
- `python-multipart==0.0.6` - обработка multipart данных

#### Frontend

```bash
cd frontend
npm install
```

### Запуск в режиме разработки

#### Backend

```bash
cd backend
python -m app.main
```

Или через uvicorn:

```bash
cd backend
uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
```

Сервер будет доступен по адресу: **http://localhost:8000**

#### Frontend

```bash
cd frontend
npm run dev
```

Приложение будет доступно по адресу: **http://localhost:5173**

### Запуск через Docker

Из корневой директории проекта:

```bash
docker-compose up
```

Это запустит оба сервиса (backend и frontend) в контейнерах.

**Порты:**
- Backend: `http://localhost:8000`
- Frontend: `http://localhost:3000` (в Docker) или `http://localhost:5173` (в dev режиме)

---

## API документация

### Основные endpoints

#### Информация о сервере

```http
GET /
```

**Ответ:**
```json
{
  "message": "Эмулятор двухадресного RISC процессора API"
}
```

#### Получить состояние эмулятора

```http
GET /api/state
```

**Ответ:**
```json
{
  "processor": {
    "registers": [0, 0, 0, 0, 0, 0, 0, 0],
    "program_counter": 0,
    "instruction_register": 0,
    "instruction_register_asm": "",
    "flags": {
      "zero": false,
      "carry": false,
      "overflow": false,
      "negative": false
    },
    "current_command": "",
    "is_halted": false,
    "cycles": 0
  },
  "memory": {
    "ram": [0, 0, ...],
    "history": []
  },
  "source_code": "",
  "machine_code": [],
  "current_task": null
}
```

#### Компиляция исходного кода

```http
POST /api/compile
Content-Type: application/json

{
  "source_code": "LDI R0, 10\nADD R0, R0, 5\nHALT"
}
```

**Ответ (успех):**
```json
{
  "success": true,
  "machine_code": ["LDI R0, 10", "ADD R0, R0, 5", "HALT"],
  "labels": {},
  "message": "Code compiled successfully"
}
```

**Ответ (ошибка):**
```json
{
  "success": false,
  "error": "Unknown instruction: INVALID",
  "message": "Compilation error: Unknown instruction: INVALID"
}
```

#### Загрузка задачи

```http
POST /api/load-task
Content-Type: application/json

{
  "task_id": 1
}
```

**Ответ:**
```json
{
  "success": true,
  "task_id": 1,
  "message": "Task loaded successfully",
  "state": { ... }
}
```

#### Выполнение программы

```http
POST /api/execute
Content-Type: application/json

{
  "task_id": 1,
  "step_by_step": false,
  "source_code": null
}
```

Или для пользовательского кода:

```http
POST /api/execute
Content-Type: application/json

{
  "task_id": null,
  "step_by_step": false,
  "source_code": "LDI R0, 10\nHALT"
}
```

**Ответ:**
```json
{
  "success": true,
  "task_id": 1,
  "verification": {
    "task_id": 1,
    "success": true,
    "expected": 280,
    "actual": 280,
    "error": null
  },
  "state": { ... }
}
```

#### Выполнение одного шага

```http
POST /api/step
```

**Ответ:**
```json
{
  "success": true,
  "state": { ... },
  "message": "Step executed"
}
```

#### Сброс процессора

```http
POST /api/reset
```

**Ответ:**
```json
{
  "success": true,
  "message": "Процессор сброшен",
  "state": { ... }
}
```

#### Получить список задач

```http
GET /api/tasks
```

**Ответ:**
```json
[
  {
    "id": 1,
    "title": "Сумма элементов массива",
    "description": "Вычислить сумму всех элементов массива..."
  },
  {
    "id": 2,
    "title": "Свертка двух массивов",
    "description": "Вычислить свертку двух массивов..."
  }
]
```

#### Получить информацию о задаче

```http
GET /api/tasks/{task_id}
```

#### Получить программу задачи

```http
GET /api/tasks/{task_id}/program
```

**Ответ:**
```json
{
  "task_id": 1,
  "program": "; Программа для вычисления суммы...",
  "test_data": [7, 10, 20, 30, 40, 50, 60, 70]
}
```

#### Получить информацию об инструкции

```http
GET /api/instruction/{instruction}
```

**Пример:**
```http
GET /api/instruction/ADD
```

### Интерактивная документация

После запуска backend доступны:

- **Swagger UI:** http://localhost:8000/docs
- **ReDoc:** http://localhost:8000/redoc
- **OpenAPI JSON:** http://localhost:8000/openapi.json

---

## Примеры программ

### Пример 1: Простое сложение

```assembly
; Загрузка констант в регистры
LDI R1, 10      ; R1 = 10
LDI R2, 20      ; R2 = 20

; Сложение
ADD R0, R1, R2  ; R0 = R1 + R2 = 30

; Остановка
HALT
```

**Результат:** R0 = 30

### Пример 2: Цикл с условием

```assembly
; Инициализация
LDI R1, 0       ; R1 = 0 (счетчик)
LDI R2, 5       ; R2 = 5 (предел)

LOOP_START:
; Проверка условия
CMP R1, R2      ; Сравнить R1 и R2
JZ LOOP_END     ; Если R1 == R2, выйти

; Тело цикла
ADD R0, R0, R1  ; R0 = R0 + R1
ADD R1, R1, 1   ; R1 = R1 + 1

; Переход к началу цикла
JMP LOOP_START

LOOP_END:
HALT
```

**Результат:** R0 = 0 + 1 + 2 + 3 + 4 = 10

### Пример 3: Работа с памятью

```assembly
; Загрузка данных в память
LDI R1, 100
STR R1, [0x1000]  ; [0x1000] = 100

; Загрузка из памяти
LDR R2, [0x1000]  ; R2 = [0x1000] = 100

; Косвенная адресация
LDI R3, 0x1000
LDRR R4, [R3]     ; R4 = [R3] = 100

HALT
```

**Результат:** R2 = 100, R4 = 100, память[0x1000] = 100

### Пример 4: Условные переходы

```assembly
; Инициализация
LDI R1, 10
LDI R2, 5

; Сравнение
CMP R1, R2      ; R1 - R2 = 10 - 5 = 5

; Условные переходы
JZ EQUAL        ; Не выполнится (результат != 0)
JNZ NOT_EQUAL   ; Выполнится (результат != 0)
JMP END

NOT_EQUAL:
LDI R0, 1       ; R0 = 1
JMP END

EQUAL:
LDI R0, 0       ; R0 = 0

END:
HALT
```

**Результат:** R0 = 1 (так как R1 != R2)

### Пример 5: Вычисление факториала

```assembly
; Вычисление факториала числа 5
LDI R1, 5       ; R1 = 5 (число)
LDI R0, 1       ; R0 = 1 (результат)
LDI R2, 1       ; R2 = 1 (для уменьшения)

FACT_LOOP:
CMP R1, R2      ; Сравнить R1 с 1
JZ FACT_END     ; Если R1 == 1, выйти

MUL R0, R0, R1  ; R0 = R0 * R1
SUB R1, R1, R2  ; R1 = R1 - 1

JMP FACT_LOOP

FACT_END:
HALT
```

**Результат:** R0 = 5! = 120

---

## Использование эмулятора

### Интерфейс процессора

Веб-интерфейс предоставляет следующие компоненты:

#### 1. Панель процессора (ProcessorView)
- **Регистры R0-R7:** отображение текущих значений всех регистров
- **Счетчик команд (PC):** текущая позиция в программе
- **Регистр команд (IR):** текущая команда в машинном коде и ассемблере
- **Флаги состояния:** Z, C, V, N с визуальными индикаторами (зеленый/красный)
- **Циклы выполнения:** счетчик выполненных команд

#### 2. Редактор команд (CommandEditor)
- Поддержка синтаксиса ассемблера
- Подсветка синтаксиса
- Компиляция в реальном времени
- Отображение ошибок компиляции
- Нумерация строк

#### 3. Просмотр памяти (MemoryView)
- Отображение содержимого ОЗУ
- История выполнения команд
- Отслеживание изменений регистров
- Форматирование данных (десятичное/шестнадцатеричное)
- Поиск по адресам

#### 4. Панель управления (ControlPanel)
- **Шаг (Step):** выполнение одной команды
- **Выполнить (Run):** выполнение всей программы
- **Сброс (Reset):** сброс процессора в начальное состояние
- **Загрузить задачу:** выбор предустановленной задачи
- **Загрузить код:** загрузка пользовательского кода

#### 5. Панель задач (TaskPanel)
- Список доступных задач
- Описание задачи
- Загрузка задачи с тестовыми данными
- Верификация результата

### Рабочий процесс

1. **Загрузка программы:**
   - Введите код в редактор или выберите задачу
   - Код автоматически компилируется
   - При ошибках компиляции они отображаются в редакторе

2. **Выполнение:**
   - **Пошагово:** нажимайте "Шаг" для выполнения одной команды
   - **Полностью:** нажмите "Выполнить" для выполнения всей программы
   - Наблюдайте за изменениями регистров, флагов и памяти

3. **Отладка:**
   - Используйте пошаговое выполнение для отслеживания изменений
   - Проверяйте значения регистров после каждой команды
   - Анализируйте историю выполнения в MemoryView

4. **Сброс:**
   - Используйте кнопку "Сброс" для возврата к начальному состоянию
   - Все регистры, флаги и память сбрасываются

---

## Особенности реализации

### Ассемблер

**Двухпроходная компиляция:**

1. **Первый проход:**
   - Парсинг исходного кода
   - Построение таблицы меток
   - Проверка синтаксиса

2. **Второй проход:**
   - Подстановка адресов меток
   - Генерация машинного кода
   - Финальная проверка

**Поддерживаемые форматы:**
- Десятичные числа: `100`, `-50`
- Шестнадцатеричные: `0x1000`, `0xFF`
- Двоичные: `0b1010`
- Метки: `LOOP_START:`, `END:`

**Обработка ошибок:**
- Неизвестные инструкции
- Неверное количество операндов
- Неопределенные метки
- Некорректные регистры (только R0-R7)
- Выход за границы памяти

### Процессор

**Выполнение команд:**
- Пошаговое выполнение с обновлением состояния
- Обновление флагов после каждой операции
- Проверка переполнения для 16-битных чисел (-32768..32767)
- Обработка ошибок выполнения (деление на ноль, выход за границы памяти)

**Управление памятью:**
- Проверка границ при доступе к памяти
- История изменений для отладки
- Инициализация памяти нулями

**Флаги состояния:**
- Автоматическое обновление после арифметических операций
- Использование флагов в условных переходах
- Визуальная индикация в интерфейсе

### Интерфейс

**Реактивное обновление:**
- Автоматическое обновление состояния при изменениях
- Анимации изменений регистров и флагов
- Поддержка разных форматов отображения (десятичный/шестнадцатеричный)

**Адаптивный дизайн:**
- Работа на разных размерах экрана
- Современный UI с использованием PrimeReact и Flowbite
- Плавные анимации и переходы

---

## Отладка и диагностика

### Логирование

Backend выводит детальные логи:
- Выполнение команд
- Изменения регистров
- Операции с памятью
- Ошибки выполнения

**Пример логов:**
```
DEBUG _parse_operand: operand_str='[0x1000]', inner='0x1000', addr=0x1000, mode=DIRECT
DEBUG _get_operand_value DIRECT: operand=0x1000, value=0x0007, memory[0x1000]=0x0007
```

### Валидация

**Проверки на этапе компиляции:**
- Корректность команд
- Количество операндов
- Существование меток
- Валидность регистров

**Проверки во время выполнения:**
- Валидация адресов памяти
- Контроль переполнения
- Проверка деления на ноль
- Верификация результатов задач

### Типичные ошибки

1. **"Unknown instruction"**
   - Проверьте правильность написания команды
   - Убедитесь, что команда поддерживается

2. **"Invalid register"**
   - Используйте только R0-R7
   - Проверьте регистр на опечатку

3. **"Division by zero"**
   - Проверьте значение делителя перед делением

4. **"OUT_OF_BOUNDS"**
   - Убедитесь, что адрес памяти в диапазоне 0x0000-0x1FFF

5. **"Undefined label"**
   - Проверьте наличие метки в коде
   - Убедитесь в правильности написания метки

---

## Требования к системе

### Минимальные требования

- **Python:** 3.8+
- **Node.js:** 16+
- **RAM:** 4 GB
- **Свободное место:** 1 GB
- **ОС:** Windows 10+, Linux, macOS

### Рекомендуемые требования

- **Python:** 3.11+
- **Node.js:** 18+
- **RAM:** 8 GB
- **Свободное место:** 2 GB
- **Браузер:** Chrome 90+, Firefox 88+, Safari 14+, Edge 90+

---

## Troubleshooting

### Проблемы с запуском

#### Backend не запускается

1. **Проверьте установку зависимостей:**
   ```bash
   cd backend
   pip install -r requirements.txt
   ```

2. **Проверьте версию Python:**
   ```bash
   python --version  # Должно быть 3.8+
   ```

3. **Проверьте занятость порта 8000:**
   ```bash
   # Windows
   netstat -ano | findstr :8000
   
   # Linux/macOS
   lsof -i :8000
   ```

#### Frontend не запускается

1. **Проверьте установку зависимостей:**
   ```bash
   cd frontend
   npm install
   ```

2. **Проверьте версию Node.js:**
   ```bash
   node --version  # Должно быть 16+
   ```

3. **Очистите кэш:**
   ```bash
   rm -rf node_modules package-lock.json
   npm install
   ```

#### CORS ошибки

Если возникают CORS ошибки, убедитесь, что:
- Backend запущен на порту 8000
- Frontend запущен на порту 5173
- В `main.py` настроены правильные `allow_origins`

#### Docker проблемы

1. **Проверьте запуск Docker:**
   ```bash
   docker --version
   docker-compose --version
   ```

2. **Пересоберите образы:**
   ```bash
   docker-compose build --no-cache
   docker-compose up
   ```

### Проблемы с выполнением программ

1. **Программа не выполняется:**
   - Проверьте наличие команды `HALT` в конце
   - Убедитесь, что код скомпилирован без ошибок

2. **Неправильные результаты:**
   - Используйте пошаговое выполнение для отладки
   - Проверяйте значения регистров после каждой команды
   - Убедитесь в правильности алгоритма

3. **Бесконечный цикл:**
   - Проверьте условия выхода из цикла
   - Убедитесь, что счетчик цикла изменяется

---

## Лицензия

Проект разработан в учебных целях для демонстрации принципов работы процессора и системы команд.

---

## Поддержка

При возникновении проблем:

1. Проверьте установлены ли все зависимости
2. Убедитесь, что оба сервера запущены (backend и frontend)
3. Проверьте отсутствие конфликтов портов
4. Изучите примеры программ в разделе "Примеры программ"
5. Обратитесь к документации API: http://localhost:8000/docs

---

## Дополнительные ресурсы

### Полезные ссылки

- [FastAPI документация](https://fastapi.tiangolo.com/)
- [React документация](https://react.dev/)
- [TypeScript документация](https://www.typescriptlang.org/)
- [RISC архитектура](https://ru.wikipedia.org/wiki/RISC)

### Структура проекта

```
assembly_emulator_v2/
├── backend/              # Backend приложение
│   ├── app/              # Основной код приложения
│   ├── requirements.txt  # Python зависимости
│   └── Dockerfile        # Docker образ
├── frontend/             # Frontend приложение
│   ├── src/              # Исходный код
│   ├── package.json      # Node.js зависимости
│   └── Dockerfile        # Docker образ
├── docker-compose.yml     # Docker Compose конфигурация
└── README.md             # Этот файл
```

---

**Версия:** 2.0.0  
**Последнее обновление:** 2024
